[prepeocess_selection_bestk.py](preprocess_selection_bestk_LR.py)
```angular2html
import pandas as pd
import numpy as np
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.preprocessing import StandardScaler
import seaborn as sns
import matplotlib.pyplot as plt
import os
import tifffile as tiff
from sklearn.model_selection import cross_val_score
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression


# 1. 移除高度相关的特征
def remove_highly_correlated_features(df, threshold=0.9):  #  ↓下面还有！！！ 阈值越低，筛掉的越多（默认阈值）
    corr_matrix = df.corr().abs()
    upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    to_drop = [column for column in upper.columns if any(upper[column] > threshold)]
    return df.drop(columns=to_drop), to_drop



# 2. 保存特征相关性的热图  意义：热图可视化有助于直观地理解特征之间的相关性，为特征选择和模型优化提供参考。
def save_heatmap(df, output_folder, filename="feature_heatmap_bestk.tiff"):
  plt.figure(figsize=(10, 8))
  # 将 annot 参数设置为 True 以显示数值
  sns.heatmap(df.corr(), annot=True, fmt=".2f", cmap='coolwarm', xticklabels=True, yticklabels=True)
  plt.xticks(rotation=45, ha='right', fontsize=8)  # 调整x轴标签的字体大小和旋转角度
  plt.yticks(fontsize=8)  # 调整y轴标签的字体大小
  plt.title('Feature Correlation Heatmap')
  plt.tight_layout()
  if not os.path.exists(output_folder):
    os.makedirs(output_folder)
  output_path = os.path.join(output_folder, filename)
  plt.savefig(output_path, format='tiff')
  plt.close()
  print(f"Heatmap saved to {output_path}")


# 3. 使用ANOVA选择特征：通过交叉验证找到最佳的k值。选择与目标变量最相关的特征，可以提高模型的预测准确性，并减少训练时间。
def find_best_k(X, y, min_k=1, max_k=None, cv=5):   #  CV 交叉验证的折数！！！！！
  """
  通过交叉验证找到最佳的k值。

  参数:
  - X: 特征数据集。
  - y: 目标变量。
  - min_k: 考虑的最小特征数量。
  - max_k: 考虑的最大特征数量。如果为None，则设置为特征数量。
  - cv: 交叉验证的折数。

  返回:
  - best_k: 最佳的特征数量。
  - best_score: 对应的最佳分数。
  """
  if max_k is None:
    max_k = X.shape[1]

  scores = []
  k_values = range(min_k, max_k + 1)

  for k in k_values:
    selector = SelectKBest(f_classif, k=k)
    model = LogisticRegression(max_iter=1000)
    pipeline = Pipeline([('selector', selector), ('model', model)])
    score = cross_val_score(pipeline, X, y, cv=cv, scoring='accuracy').mean()
    scores.append(score)

  best_score = max(scores)
  best_k = k_values[scores.index(best_score)]

  print(f"Best k: {best_k} with score: {best_score}")
  return best_k, best_score


def preprocess_and_select_features_with_best_k(data_path, output_folder):
  df = pd.read_csv(data_path)
  y = df.pop('event')
  time = df.pop('time')
  ID =  df.pop('ID')
  X = df.select_dtypes(include=[np.number])

  scaler = StandardScaler()
  X_scaled = scaler.fit_transform(X)
  X_scaled = pd.DataFrame(X_scaled, columns=X.columns)

  X_filtered, dropped_features = remove_highly_correlated_features(X_scaled, threshold=0.86) # （实际调用，覆盖默认）阈值越低，筛掉的越多

  # 找到最佳的k值
  best_k, _ = find_best_k(X_filtered, y)

  # 使用最佳的k值进行特征选择
  selector = SelectKBest(f_classif, k=best_k)
  X_selected = selector.fit_transform(X_filtered, y)
  selected_features = X_filtered.columns[selector.get_support()]

  # 保存筛选后的特征
  X_selected_df = pd.DataFrame(X_selected, columns=selected_features)

  X_selected_df['time'] = time.values
  X_selected_df['event'] = y.values
  X_selected_df['ID'] = ID.values

  selected_features_file = os.path.join(output_folder, "selected_features_with_bestk.csv") # 所有体素特徵
  X_selected_df.to_csv(selected_features_file, index=False)
  print(f"Selected features with best k saved to {selected_features_file}")

  # 绘制并保存热图
  save_heatmap(X_selected_df.drop(['event', 'time','ID'], axis=1), output_folder)


# Example call
data_path = r"D:\zhuomian\pyradiomics\pyradiomics-master\examples\output\final\radiomics_R3B12_ID_updated.csv"
output_folder = r"D:\zhuomian\pyradiomics\pyradiomics-master\radiomics\data_Conversion_and_extraction\Supervised learning\FeaturesOutput\raw_data"
preprocess_and_select_features_with_best_k(data_path, output_folder)

```
[preprocess_selection _bestk_allHeat.py](preprocess_selection%20_bestk_allHeat.py)
```angular2html
import pandas as pd
import numpy as np
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.preprocessing import StandardScaler
import seaborn as sns
import matplotlib.pyplot as plt
import os
import tifffile as tiff
from sklearn.model_selection import cross_val_score
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression

# 在数据预处理和特征选择之前，绘制原始数据的热图
def save_initial_heatmap(df, output_folder, filename="initial_feature_heatmap_allHeat.tiff"):
  # 选择数值型列
  df_numeric = df.select_dtypes(include=[np.number])

  plt.figure(figsize=(12, 10))
  sns.heatmap(df_numeric.corr(), annot=False, cmap='coolwarm', xticklabels=False, yticklabels=False)
  plt.title('Initial Feature Correlation Heatmap')
  plt.tight_layout()
  if not os.path.exists(output_folder):
    os.makedirs(output_folder)
  output_path = os.path.join(output_folder, filename)
  plt.savefig(output_path, format='tiff', dpi=300)
  plt.close()
  print(f"Initial heatmap saved to {output_path}")


# 1. 移除高度相关的特征
def remove_highly_correlated_features(df, threshold=0.9):  # ↓下面实际调用。 阈值越低，筛掉的越多（默认阈值）
    corr_matrix = df.corr().abs()
    upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    to_drop = [column for column in upper.columns if any(upper[column] > threshold)]
    return df.drop(columns=to_drop), to_drop

# 移除高度相关的特征后，绘制热图
def save_heatmap_after_removal(df, output_folder, filename="feature_heatmap_after_removal_allHeat.tiff"):
  plt.figure(figsize=(12, 10))  # 可以根据需要调整大小
  sns.heatmap(df.corr(), annot=False, cmap='coolwarm', xticklabels=False, yticklabels=False)
  plt.title('Feature Correlation Heatmap After Removal')
  plt.tight_layout()
  if not os.path.exists(output_folder):
    os.makedirs(output_folder)
  output_path = os.path.join(output_folder, filename)
  plt.savefig(output_path, format='tiff', dpi=300)  # 增加dpi参数提高图像质量
  plt.close()
  print(f"Heatmap saved to {output_path}")


# 2. 保存特征相关性的热图  意义：热图可视化有助于直观地理解特征之间的相关性，为特征选择和模型优化提供参考。
def save_heatmap(df, output_folder, filename="feature_heatmap_bestk_allHeat.tiff"):
  plt.figure(figsize=(10, 8))
  # 将 annot 参数设置为 True 以显示数值
  sns.heatmap(df.corr(), annot=True, fmt=".2f", cmap='coolwarm', xticklabels=True, yticklabels=True)
  plt.xticks(rotation=45, ha='right', fontsize=8)  # 调整x轴标签的字体大小和旋转角度
  plt.yticks(fontsize=8)  # 调整y轴标签的字体大小
  plt.title('Feature Correlation Heatmap')
  plt.tight_layout()
  if not os.path.exists(output_folder):
    os.makedirs(output_folder)
  output_path = os.path.join(output_folder, filename)
  plt.savefig(output_path, format='tiff')
  plt.close()
  print(f"Heatmap saved to {output_path}")


# 3. 使用ANOVA选择特征：通过交叉验证找到最佳的k值。选择与目标变量最相关的特征，可以提高（逻辑回归）模型的预测准确性，并减少训练时间。
def find_best_k(X, y, min_k=1, max_k=None, cv=5):  #  CV 交叉验证的折数！！！！！
  """
  通过交叉验证找到最佳的k值。

  参数:
  - X: 特征数据集。
  - y: 目标变量。
  - min_k: 考虑的最小特征数量。
  - max_k: 考虑的最大特征数量。如果为None，则设置为特征数量。
  - cv: 交叉验证的折数。

  返回:
  - best_k: 最佳的特征数量。
  - best_score: 对应的最佳分数。
  """
  if max_k is None:
    max_k = X.shape[1]

  scores = []
  k_values = range(min_k, max_k + 1)

  for k in k_values:
    selector = SelectKBest(f_classif, k=k)
    model = LogisticRegression(max_iter=1000)
    pipeline = Pipeline([('selector', selector), ('model', model)])
    score = cross_val_score(pipeline, X, y, cv=cv, scoring='accuracy').mean()
    scores.append(score)

  best_score = max(scores)
  best_k = k_values[scores.index(best_score)]

  print(f"Best k: {best_k} with score: {best_score}")
  return best_k, best_score

#  预处理和选择最佳k个特征
def preprocess_and_select_features_with_best_k(data_path, output_folder):
  df = pd.read_csv(data_path)
  y = df.pop('event')
  time = df.pop('time')
  ID =  df.pop('ID')
  X = df.select_dtypes(include=[np.number])

  # 在数据预处理和特征选择之前，绘制并保存原始数据的热图
  save_initial_heatmap(df, output_folder)

  scaler = StandardScaler()
  X_scaled = scaler.fit_transform(X)
  X_scaled = pd.DataFrame(X_scaled, columns=X.columns)

  # 移除高度相关的特征后，保存热图
  X_filtered, dropped_features = remove_highly_correlated_features(X_scaled, threshold=0.88)  #（实际调用，覆盖默认）阈值越低，筛掉的越多
  save_heatmap_after_removal(X_filtered, output_folder, "heatmap_after_removing_correlation_allHeat.tiff")

  # 找到最佳的k值
  best_k, _ = find_best_k(X_filtered, y)

  # 使用最佳的k值进行特征选择
  selector = SelectKBest(f_classif, k=best_k)
  X_selected = selector.fit_transform(X_filtered, y)
  selected_features = X_filtered.columns[selector.get_support()]

  # 保存筛选后的特征
  X_selected_df = pd.DataFrame(X_selected, columns=selected_features)

  X_selected_df['time'] = time.values
  X_selected_df['event'] = y.values
  X_selected_df['ID'] = ID.values
  selected_features_file = os.path.join(output_folder, "selected_features_with_bestk_allHeat.csv")
  X_selected_df.to_csv(selected_features_file, index=False)
  print(f"Selected features with best k saved to {selected_features_file}")

  # 绘制并保存热图
  save_heatmap(X_selected_df.drop(['event', 'time','ID'], axis=1), output_folder)


# Example call
data_path = r"D:\zhuomian\pyradiomics\pyradiomics-master\examples\output\final\radiomics_R3B12_ID_updated.csv"
output_folder = r"D:\zhuomian\pyradiomics\pyradiomics-master\radiomics\data_Conversion_and_extraction\Supervised learning\FeaturesOutput\raw_data"
preprocess_and_select_features_with_best_k(data_path, output_folder)
```
[preprocess_selection_k10.py](preprocess_selection_k10.py)
```angular2html
import pandas as pd
import numpy as np
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.preprocessing import StandardScaler
import seaborn as sns
import matplotlib.pyplot as plt
import os
import tifffile as tiff

# 1. 移除高度相关的特征
def remove_highly_correlated_features(df, threshold=0.7):  # threshold：相关系数的阈值，用于判断特征是否高度相关。
    corr_matrix = df.corr().abs()
    upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    to_drop = [column for column in upper.columns if any(upper[column] > threshold)]
    return df.drop(columns=to_drop), to_drop


# 2. 使用ANOVA选择特征： k：要选择的特征数量。意义：通过选择与目标变量最相关的特征，可以提高模型的预测准确性，并减少训练时间。
def feature_selection_anova(X, y, k=10):
    selector = SelectKBest(f_classif, k=k)
    X_new = selector.fit_transform(X, y)
    selected_features = X.columns[selector.get_support()]
    return pd.DataFrame(X_new, columns=selected_features), selected_features

# 3. 保存特征相关性的热图  意义：热图可视化有助于直观地理解特征之间的相关性，为特征选择和模型优化提供参考。
def save_heatmap(df, output_folder, filename="feature_heatmap_k10.tiff"):
  plt.figure(figsize=(10, 8))
  # 将 annot 参数设置为 True 以显示数值
  sns.heatmap(df.corr(), annot=True, fmt=".2f", cmap='coolwarm', xticklabels=True, yticklabels=True)
  plt.xticks(rotation=45, ha='right', fontsize=8)  # 调整x轴标签的字体大小和旋转角度
  plt.yticks(fontsize=8)  # 调整y轴标签的字体大小
  plt.title('Feature Correlation Heatmap')
  plt.tight_layout()
  if not os.path.exists(output_folder):
    os.makedirs(output_folder)
  output_path = os.path.join(output_folder, filename)
  plt.savefig(output_path, format='tiff')
  plt.close()
  print(f"Heatmap saved to {output_path}")

# 4. 预处理并选择特征
# 意义：这个流程通过减少特征数量和去除不必要的特征，有助于提高模型的性能和解释性。同时，通过可视化特征之间的相关性，可以更好地理解数据集的特性。
def preprocess_and_select_features(data_path, output_folder):
    """
    加载数据集，分离目标变量event和不参与特征选择的time列。
    对数值型特征进行标准化处理。
    移除高度相关的特征。
    使用ANOVA选择与目标变量最相关的k=10个特征。
    将筛选后的特征、time列和目标变量event保存到CSV文件中。
    绘制并保存特征相关性的热图。
    """
    df = pd.read_csv(data_path)
    y = df.pop('event')  # Remove the target variable
    time = df.pop('time')  # 删除时间列，但保留它以供以后使用
    ID = df.pop('ID')
    X = df.select_dtypes(include=[np.number])  # 仅选择数字列
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    X_scaled = pd.DataFrame(X_scaled, columns=X.columns)

    X_filtered_corr, dropped = remove_highly_correlated_features(X_scaled)
    print(f"Dropped features due to high correlation: {dropped}")

    X_selected, selected_features = feature_selection_anova(X_filtered_corr, y, k=10) #使用ANOVA选择与目标变量最相关的10个特征。
    print(f"Selected features: {selected_features}")

    # 将'time'列添加回最终CSV的选定特性中
    X_selected['time'] = time.values
    X_selected['event'] = y.values  # 重新添加目标变量
    X_selected['ID'] = ID.values
    selected_features_file = os.path.join(output_folder, "selection_anova_k10.csv")
    X_selected.to_csv(selected_features_file, index=False)
    print(f"Selected features k10 with event and time saved to {selected_features_file}")

    # Draw and save the heatmap
    save_heatmap(X_selected.drop(['event', 'time','ID'], axis=1), output_folder)  # 从热图中排除“事件”和“时间”

# Example call
data_path = r"D:\zhuomian\pyradiomics\pyradiomics-master\examples\output\final\radiomics_R3B12_ID_updated.csv"
output_folder = r"D:\zhuomian\pyradiomics\pyradiomics-master\radiomics\data_Conversion_and_extraction\Supervised learning\FeaturesOutput\raw_data"
preprocess_and_select_features(data_path, output_folder)
```

